// Переверните предоставленную строку и верните перевернутую строку. Например, "hello" должно стать "olleh".

function reverseString(str) {
  return str = str.split('').reverse().join(''); 
  // split разбирает строку на массив, каждая буква имеет свой индекс
  // reverse() обращает порядок элементов в массиве в обратном направлении
  // join() позволяет преобразовать и объединить все элементы массива в одно строковое значение
}

reverseString("hello");




// Факториализировать число. 
// Возвращает факториал предоставленного целого числа. Если целое число представлено буквой n, факториал представляет собой произведение всех положительных целых чисел, меньших или равных n. Факториалы часто обозначаются сокращенной записью n! Например: 5! = 1 * 2 * 3 * 4 * 5 = 120 В функцию будут переданы только целые числа, большие или равные нулю.

function factorialize(num) {
  let result = num;

  if (num === 0 || num === 1) 
    return 1; 
  
  while (num > 1) { 
    num --; // // уменьшение на 1 на каждой итерации
    result *= num;
  }

  return result;
}
factorialize(5); // 120

/* 
                    num           num--      var result      result *= num         
    1st iteration:   5             4            5             20 = 5 * 4      
    2nd iteration:   4             3           20             60 = 20 * 3
    3rd iteration:   3             2           60            120 = 60 * 2
    4th iteration:   2             1          120            120 = 120 * 1
    5th iteration:   1             0          120
    End of the WHILE loop 
    */

// console.log(factorialize(5));




// Найдите самое длинное слово в строке. 
// Возвращает длину самого длинного слова в предоставленном предложении. Ваш ответ должен быть числом.

function findLongestWordLength(str) {
  let strSplit = str.split(' '); // Разбиваем строку на массив строк. В скобках важен пробел, что б каждое слово получил свой индекс, а не буква 
  let longestWord = 0; // Инициализируем переменную, которая будет содержать в себе размер самого длинного слова

  for(var i = 0; i < strSplit.length; i++){
    if(strSplit[i].length > longestWord){ // strSplit[i].length больше, чем сравнимое слово...
	longestWord = strSplit[i].length; // затем longestWord принимает новое значение
    }
  }

  return longestWord;
};

findLongestWordLength("The quick brown fox jumped over the lazy dog"); // 6




// Возврат наибольших чисел в массивах
// Возвращает массив, состоящий из наибольшего числа из каждого предоставленного подмассива. Для простоты предоставленный массив будет содержать ровно 4 подмассива. Помните, что вы можете перебирать массив с помощью простого цикла for и обращаться к каждому члену с помощью синтаксиса массива arr[i].

function largestOfFour(arr, finalArr = []) {
  return !arr.length
    ? finalArr
    : largestOfFour(arr.slice(1), finalArr.concat(Math.max(...arr[0])))
}

largestOfFour([[4, 5, 1, 3], [13, 27, 18, 26], [32, 35, 37, 39], [1000, 1001, 857, 1]]);




// Подтвердить окончание
// Проверить, заканчивается ли строка (первый аргумент, str) заданной целевой строкой (второй аргумент, target). Эту проблему можно решить с помощью метода .endsWith(), представленного в ES2015. Но для целей этой задачи мы хотели бы, чтобы вы вместо этого использовали один из методов подстроки JavaScript.

function confirmEnding(str, target) {
  return str.slice(str.length - target.length) === target;
  // slice копирует или извлекает заданное количество элементов в новый массив
}

confirmEnding("Bastian", "n"); // true




// Повторить строку. 
// Повторить заданную строку str (первый аргумент) num раз (второй аргумент). Возвращает пустую строку, если num не является положительным числом. В этой задаче не используйте встроенный метод .repeat().

function repeatStringNumTimes(str, num) {
  let repeatedString = "";

  while (num > 0) {
    repeatedString += str;
    num--;
  }

  return repeatedString;

  /* While loop logic
                      Condition       T/F       repeatedString += string      repeatedString        times
    First iteration    (3 > 0)        true            "" + "abc"                  "abc"               2
    Second iteration   (2 > 0)        true           "abc" + "abc"               "abcabc"             1
    Third iteration    (1 > 0)        true          "abcabc" + "abc"            "abcabcabc"           0
    Fourth iteration   (0 > 0)        false
    }
  */
};

repeatStringNumTimes("abc", 3);




// Обрезать строку (первый аргумент), если она длиннее заданной максимальной длины строки (второй аргумент). Вернуть усеченную строку с ... окончанием.

function truncateString(str, num) {
  return str.length > num ? str.slice(0, num) + "..." : str;
}

truncateString("A-tisket a-tasket A green and yellow basket", 8); // A-tisket...




// Создайте функцию, которая просматривает массив arr и возвращает первый элемент в нем, прошедший «проверку на истинность». Это означает, что для данного элемента x «проверка на истинность» пройдена, если func(x) истинна. Если ни один элемент не проходит проверку, возвращается значение undefined.

function findElement(arr, func) {
  return arr.find(func);

  //  find() вернёт первый найденный в массиве элемент, который подходит под условие в переданной колбэк-функции.
}

findElement([1, 2, 3, 4], num => num % 2 === 0); // 2




// Проверьте, классифицируется ли значение как логический примитив. Вернуть истину или ложь. Булевы примитивы бывают истинными и ложными.

function booWho(bool) {
  return typeof bool == "boolean";
}

booWho(null); // false




// Заголовок в предложении 
// Вернуть предоставленную строку с заглавной первой буквой каждого слова. Убедитесь, что остальная часть слова находится в нижнем регистре. В этом упражнении вы также должны писать с большой буквы соединительные слова, такие как the и of.

function titleCase(str) {
  return str
    .toLowerCase()
    .split(" ")
    .map(val => val.replace(val.charAt(0), val.charAt(0).toUpperCase()))
    .join(" ");
}

titleCase("I'm a little tea pot");

// переводим всю строку в нижний регистр, а затем преобразовываем ее в массив. Затем мы используем map, чтобы заменить строчные буквы на прописные. Dозвращаем строку, используя метод соединения.
// charAt() возвращает символ по заданному индексу внутри строки. Индекс первого символа равен нулю




// Slice and Splice
// Вам даны два массива и индекс. Скопируйте каждый элемент первого массива во второй массив по порядку. Начните вставлять элементы с индекса n второго массива. Вернуть полученный массив. Входные массивы должны оставаться неизменными после запуска функции.

function frankenSplice(arr1, arr2, n) {
  return [...arr2.slice(0, n), ...arr1, ...arr2.slice(n)];
}

frankenSplice([1, 2, 3], [4, 5, 6], 1);

// Первый оператор расширения использует метод среза, чтобы дать только часть arr2 от индекса 0 до «n». Второй оператор распространения передает все элементы из arr1. Третий оператор расширения использует метод slice для возврата всех элементов, начиная с индекса «n» и заканчивая концом массива.




// Удалить все ложные значения из массива. Вернуть новый массив; не изменяйте исходный массив. Ложными значениями в JavaScript являются false, null, 0, "", undefined и NaN. Подсказка: попробуйте преобразовать каждое значение в логическое значение

function bouncer(arr) {
  return arr.filter(Boolean);
}

bouncer([7, "ate", "", false, 9]); // [ 7, 'ate', 9 ]




// Верните наименьший индекс, по которому значение (второй аргумент) должно быть вставлено в массив (первый аргумент) после его сортировки. Возвращаемое значение должно быть числом. 

// Например, getIndexToIns([1,2,3,4], 1.5) должна возвращать 1, поскольку она больше 1 (индекс 0), но меньше 2 (индекс 1). 

// Аналогично, getIndexToIns([20,3,5], 19) должен возвращать 2, потому что после сортировки массив будет выглядеть как [3,5,20], а 19 меньше 20 (индекс 2) и больше 5 ( индекс 1).

function getIndexToIns(arr, num) {
  arr.sort((a, b) => a - b); // Сначала отсортироваваю массив от низшего к высшему, слева направо.

  for (let i = 0; i < arr.length; i++) {
    if (arr[i] >= num) return i;
  } // сравниваем элементы в массиве, начиная с наименьшего. Когда элемент в массиве больше числа, с которым мы сравниваем, мы возвращаем индекс

  return arr.length;
}

getIndexToIns([40, 60], 50); // 1




// Возвращает true, если строка в первом элементе массива содержит все буквы строки во втором элементе массива. Например, ["hello", "Hello"] должно возвращать значение true, поскольку все буквы второй строки присутствуют в первой строке без учета регистра. Аргументы ["hello", "hey"] должны возвращать false, потому что строка hello не содержит y. Наконец, ["Alien", "line"] должен возвращать значение true, поскольку все буквы в строке присутствуют в слове "Alien".

function mutation(arr) {
  return arr[1]
    .toLowerCase()
    .split("")
    .every(function(letter) {
      return arr[0].toLowerCase().indexOf(letter) !== -1;
    });
}

mutation(["hello", "hey"]);

// Возьмем 2ую строку в нижнем регистре и превратите ее в массив; затем убедимся, что каждая из его букв является частью первой строки в нижнем регистре. Every в основном даст вам букву за буквой для сравнения, что мы и делаем, используя indexOf в первой строке. indexOf даст -1, если текущая буква отсутствует. Мы проверяем, что это не так, потому что, если это произойдет хотя бы один раз, каждое будет ложным.




// Напишите функцию, которая разбивает массив (первый аргумент) на группы длины размера (второй аргумент) и возвращает их в виде двумерного массива.

function chunkArrayInGroups(arr, size) {
  let resArr = [];
  for (let i = 0; i < arr.length; i+=size) {
    resArr.push(arr.slice(i, i + size));
  }
  return resArr;

}

chunkArrayInGroups(["a", "b", "c", "d"], 2);
// Цикл for начинается с нуля, увеличивается на размер каждый раз в цикле и останавливается, когда достигает arr.length. Внутри нашего цикла создаем каждый фрагмент, используя arr.slice(i, i+size). Метод slice принимает 2 аргумента, 1 аргумент — это индекс начала среза, а 2 аргумент — место, где должен заканчиваться слайс, но он не вкл. конечный индекс. Добавляем этот кусок в newArr с помощью .push()




// Суммируйте все числа в диапазоне

// Получаем массив из двух чисел. Вернуть сумму этих двух чисел, плюс сумму всех чисел между ними. Наименьшее число не всегда будет первым. Например, sumAll([4,1]) должна возвращать 10, поскольку сумма всех чисел от 1 до 4 (оба включительно) равна 10.

function sumAll(arr) {
  let max = Math.max(arr[0], arr[1]); // Поскольку числа не всегда могут быть в порядке, использование max() и min() поможет нам
  let min = Math.min(arr[0], arr[1]);
  let sumBetween = 0;
  for (let i = min; i <= max; i++) {
    sumBetween += i;
  }
  return sumBetween;
}

sumAll([1, 4]);




// симметричная разница 2 массивов
// Сравните два массива и верните новый массив с любыми элементами, найденными только в одном из 2 заданных массивов, но не в обоих. Другими словами, вернуть симметричную разницу 2 массивов. Примечание. Вы можете вернуть массив с его элементами в любом порядке.

function diffArray(arr1, arr2) {
  return arr1.concat(arr2).filter(item => !arr1.includes(item) || !arr2.includes(item));
}

// concat - объединяем, после фильтруем (includes проверяет есть ли искомый элемент в массиве)

console.log(diffArray([1, 2, 3, 5], [1, 2, 3, 4, 5]));




// Найти и уничтожить 
// Предоставлен начальный массив (первый аргумент в функции), за которым следует один или несколько аргументов. Удалите все элементы из исходного массива, которые имеют то же значение, что и эти аргументы. Примечание. Вы должны использовать объект arguments.

function destroyer(arr, ...valsToRemove) { // вторым аргументом добавила все элементы, которые нужно удалить, если они повтор. в массиве
  return arr.filter(elem => !valsToRemove.includes(elem));
}

destroyer([1, 2, 3, 1, 2, 3], 2, 3);





// Преобразование строки в спинной регистр. В спинном регистре все строчные слова соединены тире.

function spinalCase(str) {
  return str
    .split(/\s|_|(?=[A-Z])/) // Разделить строку при одном из следующих условий (преобразовать в массив) встречается пробельный символ [\s] встречается символ подчеркивания [_] или за ним следует заглавная буква [(?=[A-Z])]
    .join("-") // Присоединяет к массиву, используя дефис (-)
    .toLowerCase();
}

spinalCase('This Is Spinal Tap'); // this-is-spinal-tap




// Pig Latin — это способ изменения англ. слов. Правила след.: - Если слово начинается с согласного, возьмите первый согласный или группу согласных, переместите его в конец слова и добавьте к нему ау. - Если слово начинается с гласной, просто добавьте путь в конце.

function translatePigLatin(str) {
  let consonantRegex = /^[^aeiou]+/; // регул. выраж. - все кроме согласных
  let myConsonants = str.match(consonantRegex); // если найден шаблон регулярного выражения, он сохраняет совпадение; в противном случае он возвращает ноль. match - производит поиск по заданной строке с использованием регулярного выражения
  return myConsonants !== null
    ? str
        .replace(consonantRegex, "")
        .concat(myConsonants)
        .concat("ay")  // // если найден шаблон регулярного выражения (начинается с согласных), он удаляет совпадение, добавляет совпадение в конец и добавляет «ау» в конец
    : str.concat("way"); // если шаблон регулярного выражения не найден (начинается с гласных), он просто добавляет «way» к окончанию
}

translatePigLatin("consonant");




// Поиск и замена
// Выполните поиск и замену в предложении, используя предоставленные аргументы, и верните новое предложение. Первый аргумент — это предложение для выполнения поиска и замены. Второй аргумент — это слово, которое вы будете заменять (before). Третий аргумент — это то, на что вы будете заменять второй аргумент (после). Примечание. Сохраняйте регистр первого символа в исходном слове при его замене. Например, если вы хотите заменить слово «Book» словом «dog», его следует заменить на «Dog».

function myReplace(str, before, after) {
  // Проверяем, является ли первый символ аргумента «до» заглавной или строчной буквой, и изменяем первый символ аргумента «после», чтобы он соответствовал регистру.
  if (/^[A-Z]/.test(before)) {
    after = after[0].toUpperCase() + after.substring(1)
  } else {
    after = after[0].toLowerCase() + after.substring(1)
  }

  // возвращаемая строка с аргументом «до», замененным аргументом «после» (с правильным регистром)
  return str.replace(before, after);
}

console.log(myReplace("A quick brown fox jumped over the lazy dog", "jumped", "leaped"));




// Пары цепей ДНК состоят из пар азотистых оснований. Пары оснований представлены символами AT и CG, которые образуют строительные блоки двойной спирали ДНК. В цепи ДНК отсутствует элемент спаривания. Напишите функцию для сопоставления отсутствующих пар оснований для предоставленной цепи ДНК. Для каждого символа в предоставленной строке найдите символ базовой пары. Верните результаты в виде двумерного массива. Например, для ввода GCG верните [["G", "C"], ["C","G"], ["G", "C"]] Символ и его пара объединяются в массив, и все массивы группируются в один инкапсулирующий массив.

function pairElement(str) {
  // Функция для сопоставления каждого символа с базовой парой
  const matchWithBasePair = function(char) {
    switch (char) {
      case "A":
        return ["A", "T"];
      case "T":
        return ["T", "A"];
      case "C":
        return ["C", "G"];
      case "G":
        return ["G", "C"];
    }
  };

  // Ищем пару для каждого символа в строке
  const pairs = [];
  for (let i = 0; i < str.length; i++) {
    pairs.push(matchWithBasePair(str[i]));
  }

  return pairs;
}

pairElement("GCG");




// Пропущенные буквы 
// Найдите пропущенную букву в пройденном диапазоне букв и верните ее. Если все буквы присутствуют в диапазоне, вернуть undefined.

function fearNotLetter(str) {
  for (let i = 1; i < str.length; ++i) {
    if (str.charCodeAt(i) - str.charCodeAt(i - 1) > 1) {  // Проверяем, не превышает ли разница в кодах символов между соседними символами в строке 1 (проверьте таблицу ASCII)
      return String.fromCharCode(str.charCodeAt(i - 1) + 1);  // Возвращаем отсутствующий символ ( +1 с места, где был обнаружен пробел)
    }
  }
}

// charCodeAt() возвращает числовое значение Юникода для символа по указанному индексу 

fearNotLetter("abce");




// Напишите функцию, которая принимает 2 или более массива и возвращает новый массив уникальных значений в порядке исходных предоставленных массивов. Др. словами, все значения из всех массивов должны быть включены в их исходном порядке, но без дубликатов в конечном массиве. Уникальные числа должны быть отсортированы в соответствии с их первоначальным порядком, но окончательный массив не должен быть отсортирован в числовом порядке. Проверьте тесты утверждений для примеров.

function uniteUnique() {
  return [...arguments]
    .flat() // возвращает новый массив и уменьшает вложенность массива на заданное количество уровней.
    .filter((item, ind, arr) => arr.indexOf(item) === ind);
}

uniteUnique([1, 3, 2], [5, 2, 1, 4], [2, 1]); // [ 1, 3, 2, 5, 4 ]