// Переверните предоставленную строку и верните перевернутую строку. Например, "hello" должно стать "olleh".

function reverseString(str) {
  return str = str.split('').reverse().join(''); 
  // split разбирает строку на массив, каждая буква имеет свой индекс
  // reverse() обращает порядок элементов в массиве в обратном направлении
  // join() позволяет преобразовать и объединить все элементы массива в одно строковое значение
}

reverseString("hello");




// Факториализировать число. 
// Возвращает факториал предоставленного целого числа. Если целое число представлено буквой n, факториал представляет собой произведение всех положительных целых чисел, меньших или равных n. Факториалы часто обозначаются сокращенной записью n! Например: 5! = 1 * 2 * 3 * 4 * 5 = 120 В функцию будут переданы только целые числа, большие или равные нулю.

function factorialize(num) {
  let result = num;

  if (num === 0 || num === 1) 
    return 1; 
  
  while (num > 1) { 
    num --; // // уменьшение на 1 на каждой итерации
    result *= num;
  }

  return result;
}
factorialize(5); // 120

/* 
                    num           num--      var result      result *= num         
    1st iteration:   5             4            5             20 = 5 * 4      
    2nd iteration:   4             3           20             60 = 20 * 3
    3rd iteration:   3             2           60            120 = 60 * 2
    4th iteration:   2             1          120            120 = 120 * 1
    5th iteration:   1             0          120
    End of the WHILE loop 
    */

// console.log(factorialize(5));




// Найдите самое длинное слово в строке. 
// Возвращает длину самого длинного слова в предоставленном предложении. Ваш ответ должен быть числом.

function findLongestWordLength(str) {
  let strSplit = str.split(' '); // Разбиваем строку на массив строк. В скобках важен пробел, что б каждое слово получил свой индекс, а не буква 
  let longestWord = 0; // Инициализируем переменную, которая будет содержать в себе размер самого длинного слова

  for(var i = 0; i < strSplit.length; i++){
    if(strSplit[i].length > longestWord){ // strSplit[i].length больше, чем сравнимое слово...
	longestWord = strSplit[i].length; // затем longestWord принимает новое значение
    }
  }

  return longestWord;
};

findLongestWordLength("The quick brown fox jumped over the lazy dog"); // 6




// Возврат наибольших чисел в массивах
// Возвращает массив, состоящий из наибольшего числа из каждого предоставленного подмассива. Для простоты предоставленный массив будет содержать ровно 4 подмассива. Помните, что вы можете перебирать массив с помощью простого цикла for и обращаться к каждому члену с помощью синтаксиса массива arr[i].

function largestOfFour(arr, finalArr = []) {
  return !arr.length
    ? finalArr
    : largestOfFour(arr.slice(1), finalArr.concat(Math.max(...arr[0])))
}

largestOfFour([[4, 5, 1, 3], [13, 27, 18, 26], [32, 35, 37, 39], [1000, 1001, 857, 1]]);




// Подтвердить окончание
// Проверить, заканчивается ли строка (первый аргумент, str) заданной целевой строкой (второй аргумент, target). Эту проблему можно решить с помощью метода .endsWith(), представленного в ES2015. Но для целей этой задачи мы хотели бы, чтобы вы вместо этого использовали один из методов подстроки JavaScript.

function confirmEnding(str, target) {
  return str.slice(str.length - target.length) === target;
  // slice копирует или извлекает заданное количество элементов в новый массив
}

confirmEnding("Bastian", "n"); // true




// Повторить строку. 
// Повторить заданную строку str (первый аргумент) num раз (второй аргумент). Возвращает пустую строку, если num не является положительным числом. В этой задаче не используйте встроенный метод .repeat().

function repeatStringNumTimes(str, num) {
  let repeatedString = "";

  while (num > 0) {
    repeatedString += str;
    num--;
  }

  return repeatedString;

  /* While loop logic
                      Condition       T/F       repeatedString += string      repeatedString        times
    First iteration    (3 > 0)        true            "" + "abc"                  "abc"               2
    Second iteration   (2 > 0)        true           "abc" + "abc"               "abcabc"             1
    Third iteration    (1 > 0)        true          "abcabc" + "abc"            "abcabcabc"           0
    Fourth iteration   (0 > 0)        false
    }
  */
};

repeatStringNumTimes("abc", 3);




// Обрезать строку (первый аргумент), если она длиннее заданной максимальной длины строки (второй аргумент). Вернуть усеченную строку с ... окончанием.

function truncateString(str, num) {
  return str.length > num ? str.slice(0, num) + "..." : str;
}

truncateString("A-tisket a-tasket A green and yellow basket", 8); // A-tisket...




// Создайте функцию, которая просматривает массив arr и возвращает первый элемент в нем, прошедший «проверку на истинность». Это означает, что для данного элемента x «проверка на истинность» пройдена, если func(x) истинна. Если ни один элемент не проходит проверку, возвращается значение undefined.

function findElement(arr, func) {
  return arr.find(func);

  //  find() вернёт первый найденный в массиве элемент, который подходит под условие в переданной колбэк-функции.
}

findElement([1, 2, 3, 4], num => num % 2 === 0); // 2




// Проверьте, классифицируется ли значение как логический примитив. Вернуть истину или ложь. Булевы примитивы бывают истинными и ложными.

function booWho(bool) {
  return typeof bool == "boolean";
}

booWho(null); // false




// Заголовок в предложении 
// Вернуть предоставленную строку с заглавной первой буквой каждого слова. Убедитесь, что остальная часть слова находится в нижнем регистре. В этом упражнении вы также должны писать с большой буквы соединительные слова, такие как the и of.

function titleCase(str) {
  return str
    .toLowerCase()
    .split(" ")
    .map(val => val.replace(val.charAt(0), val.charAt(0).toUpperCase()))
    .join(" ");
}

titleCase("I'm a little tea pot");

// переводим всю строку в нижний регистр, а затем преобразовываем ее в массив. Затем мы используем map, чтобы заменить строчные буквы на прописные. Dозвращаем строку, используя метод соединения.
// charAt() возвращает символ по заданному индексу внутри строки. Индекс первого символа равен нулю




// Slice and Splice
// Вам даны два массива и индекс. Скопируйте каждый элемент первого массива во второй массив по порядку. Начните вставлять элементы с индекса n второго массива. Вернуть полученный массив. Входные массивы должны оставаться неизменными после запуска функции.

function frankenSplice(arr1, arr2, n) {
  return [...arr2.slice(0, n), ...arr1, ...arr2.slice(n)];
}

frankenSplice([1, 2, 3], [4, 5, 6], 1);

// Первый оператор расширения использует метод среза, чтобы дать только часть arr2 от индекса 0 до «n». Второй оператор распространения передает все элементы из arr1. Третий оператор расширения использует метод slice для возврата всех элементов, начиная с индекса «n» и заканчивая концом массива.




// Удалить все ложные значения из массива. Вернуть новый массив; не изменяйте исходный массив. Ложными значениями в JavaScript являются false, null, 0, "", undefined и NaN. Подсказка: попробуйте преобразовать каждое значение в логическое значение

function bouncer(arr) {
  return arr.filter(Boolean);
}

bouncer([7, "ate", "", false, 9]); // [ 7, 'ate', 9 ]




// Верните наименьший индекс, по которому значение (второй аргумент) должно быть вставлено в массив (первый аргумент) после его сортировки. Возвращаемое значение должно быть числом. 

// Например, getIndexToIns([1,2,3,4], 1.5) должна возвращать 1, поскольку она больше 1 (индекс 0), но меньше 2 (индекс 1). 

// Аналогично, getIndexToIns([20,3,5], 19) должен возвращать 2, потому что после сортировки массив будет выглядеть как [3,5,20], а 19 меньше 20 (индекс 2) и больше 5 ( индекс 1).

function getIndexToIns(arr, num) {
  arr.sort((a, b) => a - b); // Сначала отсортироваваю массив от низшего к высшему, слева направо.

  for (let i = 0; i < arr.length; i++) {
    if (arr[i] >= num) return i;
  } // сравниваем элементы в массиве, начиная с наименьшего. Когда элемент в массиве больше числа, с которым мы сравниваем, мы возвращаем индекс

  return arr.length;
}

getIndexToIns([40, 60], 50); // 1




// Возвращает true, если строка в первом элементе массива содержит все буквы строки во втором элементе массива. Например, ["hello", "Hello"] должно возвращать значение true, поскольку все буквы второй строки присутствуют в первой строке без учета регистра. Аргументы ["hello", "hey"] должны возвращать false, потому что строка hello не содержит y. Наконец, ["Alien", "line"] должен возвращать значение true, поскольку все буквы в строке присутствуют в слове "Alien".

function mutation(arr) {
  return arr[1]
    .toLowerCase()
    .split("")
    .every(function(letter) {
      return arr[0].toLowerCase().indexOf(letter) !== -1;
    });
}

mutation(["hello", "hey"]);

// Возьмем 2ую строку в нижнем регистре и превратите ее в массив; затем убедимся, что каждая из его букв является частью первой строки в нижнем регистре. Every в основном даст вам букву за буквой для сравнения, что мы и делаем, используя indexOf в первой строке. indexOf даст -1, если текущая буква отсутствует. Мы проверяем, что это не так, потому что, если это произойдет хотя бы один раз, каждое будет ложным.




// Напишите функцию, которая разбивает массив (первый аргумент) на группы длины размера (второй аргумент) и возвращает их в виде двумерного массива.

function chunkArrayInGroups(arr, size) {
  let resArr = [];
  for (let i = 0; i < arr.length; i+=size) {
    resArr.push(arr.slice(i, i + size));
  }
  return resArr;

}

chunkArrayInGroups(["a", "b", "c", "d"], 2);
// Цикл for начинается с нуля, увеличивается на размер каждый раз в цикле и останавливается, когда достигает arr.length. Внутри нашего цикла создаем каждый фрагмент, используя arr.slice(i, i+size). Метод slice принимает 2 аргумента, 1 аргумент — это индекс начала среза, а 2 аргумент — место, где должен заканчиваться слайс, но он не вкл. конечный индекс. Добавляем этот кусок в newArr с помощью .push()




// Суммируйте все числа в диапазоне

// Получаем массив из двух чисел. Вернуть сумму этих двух чисел, плюс сумму всех чисел между ними. Наименьшее число не всегда будет первым. Например, sumAll([4,1]) должна возвращать 10, поскольку сумма всех чисел от 1 до 4 (оба включительно) равна 10.

function sumAll(arr) {
  let max = Math.max(arr[0], arr[1]); // Поскольку числа не всегда могут быть в порядке, использование max() и min() поможет нам
  let min = Math.min(arr[0], arr[1]);
  let sumBetween = 0;
  for (let i = min; i <= max; i++) {
    sumBetween += i;
  }
  return sumBetween;
}

sumAll([1, 4]);




// симметричная разница 2 массивов
// Сравните два массива и верните новый массив с любыми элементами, найденными только в одном из 2 заданных массивов, но не в обоих. Другими словами, вернуть симметричную разницу 2 массивов. Примечание. Вы можете вернуть массив с его элементами в любом порядке.

function diffArray(arr1, arr2) {
  return arr1.concat(arr2).filter(item => !arr1.includes(item) || !arr2.includes(item));
}

// concat - объединяем, после фильтруем (includes проверяет есть ли искомый элемент в массиве)

console.log(diffArray([1, 2, 3, 5], [1, 2, 3, 4, 5]));




// Найти и уничтожить 
// Предоставлен начальный массив (первый аргумент в функции), за которым следует один или несколько аргументов. Удалите все элементы из исходного массива, которые имеют то же значение, что и эти аргументы. Примечание. Вы должны использовать объект arguments.

function destroyer(arr, ...valsToRemove) { // вторым аргументом добавила все элементы, которые нужно удалить, если они повтор. в массиве
  return arr.filter(elem => !valsToRemove.includes(elem));
}

destroyer([1, 2, 3, 1, 2, 3], 2, 3);





// Преобразование строки в спинной регистр. В спинном регистре все строчные слова соединены тире.

function spinalCase(str) {
  return str
    .split(/\s|_|(?=[A-Z])/) // Разделить строку при одном из следующих условий (преобразовать в массив) встречается пробельный символ [\s] встречается символ подчеркивания [_] или за ним следует заглавная буква [(?=[A-Z])]
    .join("-") // Присоединяет к массиву, используя дефис (-)
    .toLowerCase();
}

spinalCase('This Is Spinal Tap'); // this-is-spinal-tap




// Pig Latin — это способ изменения англ. слов. Правила след.: - Если слово начинается с согласного, возьмите первый согласный или группу согласных, переместите его в конец слова и добавьте к нему ау. - Если слово начинается с гласной, просто добавьте путь в конце.

function translatePigLatin(str) {
  let consonantRegex = /^[^aeiou]+/; // регул. выраж. - все кроме согласных
  let myConsonants = str.match(consonantRegex); // если найден шаблон регулярного выражения, он сохраняет совпадение; в противном случае он возвращает ноль. match - производит поиск по заданной строке с использованием регулярного выражения
  return myConsonants !== null
    ? str
        .replace(consonantRegex, "")
        .concat(myConsonants)
        .concat("ay")  // // если найден шаблон регулярного выражения (начинается с согласных), он удаляет совпадение, добавляет совпадение в конец и добавляет «ау» в конец
    : str.concat("way"); // если шаблон регулярного выражения не найден (начинается с гласных), он просто добавляет «way» к окончанию
}

translatePigLatin("consonant");




// Поиск и замена
// Выполните поиск и замену в предложении, используя предоставленные аргументы, и верните новое предложение. Первый аргумент — это предложение для выполнения поиска и замены. Второй аргумент — это слово, которое вы будете заменять (before). Третий аргумент — это то, на что вы будете заменять второй аргумент (после). Примечание. Сохраняйте регистр первого символа в исходном слове при его замене. Например, если вы хотите заменить слово «Book» словом «dog», его следует заменить на «Dog».

function myReplace(str, before, after) {
  // Проверяем, является ли первый символ аргумента «до» заглавной или строчной буквой, и изменяем первый символ аргумента «после», чтобы он соответствовал регистру.
  if (/^[A-Z]/.test(before)) {
    after = after[0].toUpperCase() + after.substring(1)
  } else {
    after = after[0].toLowerCase() + after.substring(1)
  }

  // возвращаемая строка с аргументом «до», замененным аргументом «после» (с правильным регистром)
  return str.replace(before, after);
}

console.log(myReplace("A quick brown fox jumped over the lazy dog", "jumped", "leaped"));




// Пары цепей ДНК состоят из пар азотистых оснований. Пары оснований представлены символами AT и CG, которые образуют строительные блоки двойной спирали ДНК. В цепи ДНК отсутствует элемент спаривания. Напишите функцию для сопоставления отсутствующих пар оснований для предоставленной цепи ДНК. Для каждого символа в предоставленной строке найдите символ базовой пары. Верните результаты в виде двумерного массива. Например, для ввода GCG верните [["G", "C"], ["C","G"], ["G", "C"]] Символ и его пара объединяются в массив, и все массивы группируются в один инкапсулирующий массив.

function pairElement(str) {
  // Функция для сопоставления каждого символа с базовой парой
  const matchWithBasePair = function(char) {
    switch (char) {
      case "A":
        return ["A", "T"];
      case "T":
        return ["T", "A"];
      case "C":
        return ["C", "G"];
      case "G":
        return ["G", "C"];
    }
  };

  // Ищем пару для каждого символа в строке
  const pairs = [];
  for (let i = 0; i < str.length; i++) {
    pairs.push(matchWithBasePair(str[i]));
  }

  return pairs;
}

pairElement("GCG");




// Пропущенные буквы 
// Найдите пропущенную букву в пройденном диапазоне букв и верните ее. Если все буквы присутствуют в диапазоне, вернуть undefined.

function fearNotLetter(str) {
  for (let i = 1; i < str.length; ++i) {
    if (str.charCodeAt(i) - str.charCodeAt(i - 1) > 1) {  // Проверяем, не превышает ли разница в кодах символов между соседними символами в строке 1 (проверьте таблицу ASCII)
      return String.fromCharCode(str.charCodeAt(i - 1) + 1);  // Возвращаем отсутствующий символ ( +1 с места, где был обнаружен пробел)
    }
  }
}

// charCodeAt() возвращает числовое значение Юникода для символа по указанному индексу 

fearNotLetter("abce");




// Напишите функцию, которая принимает 2 или более массива и возвращает новый массив уникальных значений в порядке исходных предоставленных массивов. Др. словами, все значения из всех массивов должны быть включены в их исходном порядке, но без дубликатов в конечном массиве. Уникальные числа должны быть отсортированы в соответствии с их первоначальным порядком, но окончательный массив не должен быть отсортирован в числовом порядке. Проверьте тесты утверждений для примеров.

function uniteUnique() {
  return [...arguments]
    .flat() // возвращает новый массив и уменьшает вложенность массива на заданное количество уровней.
    .filter((item, ind, arr) => arr.indexOf(item) === ind);
}

uniteUnique([1, 3, 2], [5, 2, 1, 4], [2, 1]); // [ 1, 3, 2, 5, 4 ]




// Суммируй все нечетные числа
// Учитывая положительное целое число, вернуть сумму всех нечетных чисел Фибоначчи, которые меньше или равны num. Первые два числа в последовательности Фибоначчи — это 1 и 1. Каждое дополнительное число в последовательности является суммой двух предыдущих чисел. Первые шесть чисел последовательности Фибоначчи — это 1, 1, 2, 3, 5 и 8. Например, sumFibs(10) должно возвращать 10, потому что все нечетные числа Фибоначчи, меньшие или равные 10, равны 1, 1, 3 и 5.

function sumFibs(sum) {
  let prevNumber = 0; // предыдущие число
  let currNumber = 1; // след. число
  let result = 0;

  while(currNumber <= 0) { // Используем while, чтобы убедиться, что мы не превышаем число, указанное в качестве параметра.
    if(currNumber % 2 !== 0) { // проверяем нечетное или четное
      result += currNumber; // если нечетное, то прибавляем к результату
    }
    result += currNumber;
    prevNumber = currNumber - prevNumber;
  } // Завершаем круг Фибоначчи, вращая, получая следующее число и меняя местами значения после.

  return result;
};

sumFibs(4);




// Сумма всех простых чисел
// Простое число — это целое число больше 1, имеющее ровно два делителя: 1 и само себя. Например, 2 — простое число, потому что оно делится только на 1 и 2. Напротив, 4 не является простым, поскольку делится на 1, 2 и 4. Перепишите sumPrimes так, чтобы он возвращал сумму всех простых чисел, которые меньше или равны num

function sumPrimes(num) {
  // Вспомогательная функция для проверки простоты
  function isPrime(num) {
    const sqrt = Math.sqrt(sum);

    for (let i = 2; i <= sqrt; i++) {
      if(num % i === 0) {
        return false;
      };
      return true;
    }

    // Проверяем все числа на простоту 

    let sum = 0;
    for (let i = 2; i <= num; i++) {
      if(isPrime(i)) {
        sum += i;
      }
      return sum;
    }
  }
};

sumPrimes(10);

// перебираем все значения в нашем диапазоне, добавляя их к сумме, если они простые. Функция проверки простоты возвращает false, если целевое число делится на любое число в диапазоне от 2 до квадратного корня из целевого числа. Нужно проверить квадратный корень, т. к. — это наибольший возможный уникальный делитель.




// Наименьшее общее кратное 
// Найдите наименьшее общее кратное заданных параметров, которое можно без остатка разделить на оба, а также на все порядковые номера в диапазоне между этими параметрами. Диапазон будет массивом из двух чисел, которые не обязательно будут упорядочены по порядку. Например, если даны 1 и 3, найдите наименьшее общее кратное 1 и 3, которое также делится без остатка на все числа от 1 до 3. Ответом здесь будет 6.

function smallestCommons(arr) {
  // Настраиваем
  const [min, max] = arr.sort((a, b) => a - b);
  const range = Array(max - min + 1)
    .fill(0)
    .map((_, i) => i + min);
  // Максимально возможное значение для SCM
  const upperBound = range.reduce((prod, curr) => prod * curr);
  // Протестируйте все кратные 'max'
  for (let multiple = max; multiple <= upperBound; multiple += max) {
    // Проверьте, делит ли каждое значение в диапазоне «несколько»
    const divisible = range.every((value) => multiple % value === 0);
    if (divisible) {
      return multiple;
    }
  }
}

smallestCommons([1, 5]); // 60




// Учитывая массив arr, перебираем и удаляем каждый элемент, начиная с первого элемента (индекс 0), пока функция func не вернет true, когда через нее пройдет итерируемый элемент. Затем верните остальную часть массива, как только условие будет выполнено, в противном случае arr должен быть возвращен как пустой массив.

function dropElements(arr, func) {
  let sliceIndex = arr.findIndex(func); // findIndex(), чтобы найти индекс элемента, который проходит условие

  return arr.slice(sliceIndex >= 0 ? sliceIndex : arr.length);
} // slice - Разрезаем массив от найденного индекса до конца
// если условие не выполняется ни для одного из элементов, findIndex вернет -1, что испортит ввод в slice(). В этом случае используем простой условный оператор, чтобы вернуть false вместо -1. И тернарный оператор возвращает найденный индекс требуемых элементов, когда условие истинно, и длину массива в противном случае, так что возвращаемое значение является пустым массивом.

dropElements([1, 2, 3, 4], function(n) {return n >= 3;}) // [3, 4]




// Сгладить вложенный массив. Вы должны учитывать различные уровни вложенности.

function steamrollArray(arr) {
  const flat = [].concat(...arr); // Используем оператор распространения, чтобы объединить каждый элемент arr с пустым массивом
  return flat.some(Array.isArray) ? steamrollArray(flat) : flat; 
  // Array.some(), чтобы узнать, содержит ли новый массив.
  // Если это так, используем рекурсию, чтобы снова вызвать steamrollArray, передав новый массив, чтобы повторить процесс для массивов, которые были глубоко вложены.
  // Если это не так, верните сглаженный массив
}

steamrollArray([1, [2], [3, [[4]]]]);




// Функция, которая возвращает переведенное на анг. язык предложение переданной двоичной строки. Двоичная строка должна быть разделена пробелом.

function binaryAgent(str) {
  return String.fromCharCode(
    ...str.split(" ").map(function(char) { 
      return parseInt(char, 2);
    })

    // split(), чтобы иметь возможность работать с каждым символом как с элементом массива.
    // Затем используйте map() для обработки каждого элемента из двоичного в десятичный, используя pareseInt()
    // String.fromCharCode() для преобразования каждого числа ASCII в соответствующий символ.
  );
}

binaryAgent("01000001 01110010 01100101 01101110 00100111 01110100 00100000 01100010 01101111 01101110 01100110 01101001 01110010 01100101 01110011 00100000 01100110 01110101 01101110 00100001 00111111"); // Aren't bonfires fun!?




// // Проверить, является ли предикат (второй аргумент) истинным для всех элементов коллекции (первый аргумент). Др. словами, вам дан массив объектов. Предикат pre будет свойством объекта, и вам нужно вернуть true, если его значение истинно. В противном случае вернуть ложь. В JavaScript истинные значения — это значения, которые преобразуются в истинные при оценке в логическом контексте. Помните, что вы можете получить доступ к свойствам объекта либо через точечную нотацию, либо через нотацию [].

function truthCheck(collection, pre) {
  return collection.every(obj => obj[pre]);
}

truthCheck([{ name: "Quincy", role: "Founder", isBot: false }, { name: "Naomi", role: "", isBot: false }, { name: "Camperbot", role: "Bot", isBot: true }], "isBot"); // false

truthCheck([{name: "Quincy", role: "Founder", isBot: false}, {name: "Naomi", role: "", isBot: false}, {name: "Camperbot", role: "Bot", isBot: true}], "name") // true

// Для каждого объекта в массиве collection проверьте истинность свойства объекта, переданного в предварительном параметре pre.
// Метод Array.prototype.every внутренне проверяет, является ли значение, возвращаемое обратным вызовом, правдивым.