// Переверните предоставленную строку и верните перевернутую строку. Например, "hello" должно стать "olleh".

function reverseString(str) {
  return str = str.split('').reverse().join(''); 
  // split разбирает строку на массив, каждая буква имеет свой индекс
  // reverse() обращает порядок элементов в массиве в обратном направлении
  // join() позволяет преобразовать и объединить все элементы массива в одно строковое значение
}

reverseString("hello");




// Факториализировать число. 
// Возвращает факториал предоставленного целого числа. Если целое число представлено буквой n, факториал представляет собой произведение всех положительных целых чисел, меньших или равных n. Факториалы часто обозначаются сокращенной записью n! Например: 5! = 1 * 2 * 3 * 4 * 5 = 120 В функцию будут переданы только целые числа, большие или равные нулю.

function factorialize(num) {
  let result = num;

  if (num === 0 || num === 1) 
    return 1; 
  
  while (num > 1) { 
    num --; // // уменьшение на 1 на каждой итерации
    result *= num;
  }

  return result;
}
factorialize(5); // 120

/* 
                    num           num--      var result      result *= num         
    1st iteration:   5             4            5             20 = 5 * 4      
    2nd iteration:   4             3           20             60 = 20 * 3
    3rd iteration:   3             2           60            120 = 60 * 2
    4th iteration:   2             1          120            120 = 120 * 1
    5th iteration:   1             0          120
    End of the WHILE loop 
    */

// console.log(factorialize(5));




// Найдите самое длинное слово в строке. 
// Возвращает длину самого длинного слова в предоставленном предложении. Ваш ответ должен быть числом.

function findLongestWordLength(str) {
  let strSplit = str.split(' '); // Разбиваем строку на массив строк. В скобках важен пробел, что б каждое слово получил свой индекс, а не буква 
  let longestWord = 0; // Инициализируем переменную, которая будет содержать в себе размер самого длинного слова

  for(var i = 0; i < strSplit.length; i++){
    if(strSplit[i].length > longestWord){ // strSplit[i].length больше, чем сравнимое слово...
	longestWord = strSplit[i].length; // затем longestWord принимает новое значение
    }
  }

  return longestWord;
};

findLongestWordLength("The quick brown fox jumped over the lazy dog"); // 6




// Возврат наибольших чисел в массивах
// Возвращает массив, состоящий из наибольшего числа из каждого предоставленного подмассива. Для простоты предоставленный массив будет содержать ровно 4 подмассива. Помните, что вы можете перебирать массив с помощью простого цикла for и обращаться к каждому члену с помощью синтаксиса массива arr[i].

function largestOfFour(arr, finalArr = []) {
  return !arr.length
    ? finalArr
    : largestOfFour(arr.slice(1), finalArr.concat(Math.max(...arr[0])))
}

largestOfFour([[4, 5, 1, 3], [13, 27, 18, 26], [32, 35, 37, 39], [1000, 1001, 857, 1]]);




// Подтвердить окончание
// Проверить, заканчивается ли строка (первый аргумент, str) заданной целевой строкой (второй аргумент, target). Эту проблему можно решить с помощью метода .endsWith(), представленного в ES2015. Но для целей этой задачи мы хотели бы, чтобы вы вместо этого использовали один из методов подстроки JavaScript.

function confirmEnding(str, target) {
  return str.slice(str.length - target.length) === target;
  // slice копирует или извлекает заданное количество элементов в новый массив
}

confirmEnding("Bastian", "n"); // true




// Повторить строку. 
// Повторить заданную строку str (первый аргумент) num раз (второй аргумент). Возвращает пустую строку, если num не является положительным числом. В этой задаче не используйте встроенный метод .repeat().

function repeatStringNumTimes(str, num) {
  let repeatedString = "";

  while (num > 0) {
    repeatedString += str;
    num--;
  }

  return repeatedString;

  /* While loop logic
                      Condition       T/F       repeatedString += string      repeatedString        times
    First iteration    (3 > 0)        true            "" + "abc"                  "abc"               2
    Second iteration   (2 > 0)        true           "abc" + "abc"               "abcabc"             1
    Third iteration    (1 > 0)        true          "abcabc" + "abc"            "abcabcabc"           0
    Fourth iteration   (0 > 0)        false
    }
  */
};

repeatStringNumTimes("abc", 3);




// Обрезать строку (первый аргумент), если она длиннее заданной максимальной длины строки (второй аргумент). Вернуть усеченную строку с ... окончанием.

function truncateString(str, num) {
  return str.length > num ? str.slice(0, num) + "..." : str;
}

truncateString("A-tisket a-tasket A green and yellow basket", 8); // A-tisket...




// Создайте функцию, которая просматривает массив arr и возвращает первый элемент в нем, прошедший «проверку на истинность». Это означает, что для данного элемента x «проверка на истинность» пройдена, если func(x) истинна. Если ни один элемент не проходит проверку, возвращается значение undefined.

function findElement(arr, func) {
  return arr.find(func);

  //  find() вернёт первый найденный в массиве элемент, который подходит под условие в переданной колбэк-функции.
}

findElement([1, 2, 3, 4], num => num % 2 === 0); // 2




// Проверьте, классифицируется ли значение как логический примитив. Вернуть истину или ложь. Булевы примитивы бывают истинными и ложными.

function booWho(bool) {
  return typeof bool == "boolean";
}

booWho(null); // false




// Заголовок в предложении 
// Вернуть предоставленную строку с заглавной первой буквой каждого слова. Убедитесь, что остальная часть слова находится в нижнем регистре. В этом упражнении вы также должны писать с большой буквы соединительные слова, такие как the и of.

function titleCase(str) {
  return str
    .toLowerCase()
    .split(" ")
    .map(val => val.replace(val.charAt(0), val.charAt(0).toUpperCase()))
    .join(" ");
}

titleCase("I'm a little tea pot");

// переводим всю строку в нижний регистр, а затем преобразовываем ее в массив. Затем мы используем map, чтобы заменить строчные буквы на прописные. Dозвращаем строку, используя метод соединения.
// charAt() возвращает символ по заданному индексу внутри строки. Индекс первого символа равен нулю




// Slice and Splice
// Вам даны два массива и индекс. Скопируйте каждый элемент первого массива во второй массив по порядку. Начните вставлять элементы с индекса n второго массива. Вернуть полученный массив. Входные массивы должны оставаться неизменными после запуска функции.

function frankenSplice(arr1, arr2, n) {
  return [...arr2.slice(0, n), ...arr1, ...arr2.slice(n)];
}

frankenSplice([1, 2, 3], [4, 5, 6], 1);

// Первый оператор расширения использует метод среза, чтобы дать только часть arr2 от индекса 0 до «n». Второй оператор распространения передает все элементы из arr1. Третий оператор расширения использует метод slice для возврата всех элементов, начиная с индекса «n» и заканчивая концом массива.




// Удалить все ложные значения из массива. Вернуть новый массив; не изменяйте исходный массив. Ложными значениями в JavaScript являются false, null, 0, "", undefined и NaN. Подсказка: попробуйте преобразовать каждое значение в логическое значение

function bouncer(arr) {
  return arr.filter(Boolean);
}

bouncer([7, "ate", "", false, 9]); // [ 7, 'ate', 9 ]




// Верните наименьший индекс, по которому значение (второй аргумент) должно быть вставлено в массив (первый аргумент) после его сортировки. Возвращаемое значение должно быть числом. 

// Например, getIndexToIns([1,2,3,4], 1.5) должна возвращать 1, поскольку она больше 1 (индекс 0), но меньше 2 (индекс 1). 

// Аналогично, getIndexToIns([20,3,5], 19) должен возвращать 2, потому что после сортировки массив будет выглядеть как [3,5,20], а 19 меньше 20 (индекс 2) и больше 5 ( индекс 1).

function getIndexToIns(arr, num) {
  arr.sort((a, b) => a - b); // Сначала отсортироваваю массив от низшего к высшему, слева направо.

  for (let i = 0; i < arr.length; i++) {
    if (arr[i] >= num) return i;
  } // сравниваем элементы в массиве, начиная с наименьшего. Когда элемент в массиве больше числа, с которым мы сравниваем, мы возвращаем индекс

  return arr.length;
}

getIndexToIns([40, 60], 50); // 1




// Возвращает true, если строка в первом элементе массива содержит все буквы строки во втором элементе массива. Например, ["hello", "Hello"] должно возвращать значение true, поскольку все буквы второй строки присутствуют в первой строке без учета регистра. Аргументы ["hello", "hey"] должны возвращать false, потому что строка hello не содержит y. Наконец, ["Alien", "line"] должен возвращать значение true, поскольку все буквы в строке присутствуют в слове "Alien".

function mutation(arr) {
  return arr[1]
    .toLowerCase()
    .split("")
    .every(function(letter) {
      return arr[0].toLowerCase().indexOf(letter) !== -1;
    });
}

mutation(["hello", "hey"]);

// Возьмем 2ую строку в нижнем регистре и превратите ее в массив; затем убедимся, что каждая из его букв является частью первой строки в нижнем регистре. Every в основном даст вам букву за буквой для сравнения, что мы и делаем, используя indexOf в первой строке. indexOf даст -1, если текущая буква отсутствует. Мы проверяем, что это не так, потому что, если это произойдет хотя бы один раз, каждое будет ложным.




// Напишите функцию, которая разбивает массив (первый аргумент) на группы длины размера (второй аргумент) и возвращает их в виде двумерного массива.

function chunkArrayInGroups(arr, size) {
  let resArr = [];
  for (let i = 0; i < arr.length; i+=size) {
    resArr.push(arr.slice(i, i + size));
  }
  return resArr;

}

chunkArrayInGroups(["a", "b", "c", "d"], 2);
// Цикл for начинается с нуля, увеличивается на размер каждый раз в цикле и останавливается, когда достигает arr.length. Внутри нашего цикла создаем каждый фрагмент, используя arr.slice(i, i+size). Метод slice принимает 2 аргумента, 1 аргумент — это индекс начала среза, а 2 аргумент — место, где должен заканчиваться слайс, но он не вкл. конечный индекс. Добавляем этот кусок в newArr с помощью .push()